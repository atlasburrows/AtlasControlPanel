@page "/chat"
@using System.Net.Http
@using System.Net.Http.Headers
@using System.Text
@using System.Text.Json
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration
@inject IHttpClientFactory HttpClientFactory
@inject IJSRuntime JS
@implements IAsyncDisposable

<div class="chat-page">
    <div class="chat-messages" id="chatMessages">
        @if (!_messages.Any() && !_isStreaming)
        {
            <div class="chat-empty">
                <div class="chat-empty-icon">üåê</div>
                <div class="chat-empty-title">Atlas</div>
                <div class="chat-empty-sub">Your messages are end-to-end with OpenClaw Gateway</div>
            </div>
        }

        @{
            string? lastDate = null;
        }
        @foreach (var msg in _messages)
        {
            var dateStr = msg.CreatedAt.ToLocalTime().ToString("MMM d, yyyy");
            @if (dateStr != lastDate)
            {
                lastDate = dateStr;
                <div class="chat-date-divider">
                    <span>@(msg.CreatedAt.ToLocalTime().Date == DateTime.Today ? "Today" :
                            msg.CreatedAt.ToLocalTime().Date == DateTime.Today.AddDays(-1) ? "Yesterday" : dateStr)</span>
                </div>
            }

            @if (msg.Role == "user")
            {
                <div class="chat-row chat-row-user">
                    <div class="chat-bubble-user">
                        <div class="chat-source-icon">@GetUserSourceIcon(msg.Content)</div>
                        <div class="chat-text">@((MarkupString)FormatMessage(CleanSourcePrefix(msg.Content)))</div>
                        <div class="chat-time-user">@msg.CreatedAt.ToLocalTime().ToString("h:mm tt")</div>
                    </div>
                </div>
            }
            else
            {
                <div class="chat-row chat-row-atlas">
                    <div class="chat-bubble-atlas">
                        <div class="chat-source-icon">üåê</div>
                        <div class="chat-text">@((MarkupString)FormatMessage(msg.Content))</div>
                        <div class="chat-time-atlas">@msg.CreatedAt.ToLocalTime().ToString("h:mm tt")</div>
                    </div>
                </div>
            }
        }

        @if (_isStreaming)
        {
            <div class="chat-row chat-row-atlas">
                <div class="chat-bubble-atlas">
                    <div class="chat-source-icon">üåê</div>
                    @if (string.IsNullOrEmpty(_streamBuffer))
                    {
                        <div class="chat-typing">
                            <span class="dot"></span><span class="dot"></span><span class="dot"></span>
                        </div>
                    }
                    else
                    {
                        <div class="chat-text">@((MarkupString)FormatMessage(_streamBuffer))</div>
                    }
                </div>
            </div>
        }
    </div>

    <button class="chat-scroll-bottom" id="chatScrollBottom" style="display:none;" @onclick="ScrollToBottom">
        <svg viewBox="0 0 24 24" width="20" height="20"><path d="M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6z" fill="currentColor"/></svg>
    </button>

    <div class="chat-input-bar">
        @if (_attachedFiles.Any())
        {
            <div class="chat-file-strip">
                @for (int i = 0; i < _attachedFiles.Count; i++)
                {
                    var idx = i;
                    var file = _attachedFiles[idx];
                    <div class="chat-file-preview @(file.IsImage ? "" : "chat-file-doc")">
                        @if (file.IsImage && file.PreviewUrl != null)
                        {
                            <img src="@file.PreviewUrl" />
                        }
                        else
                        {
                            <span class="chat-file-icon">üìÑ</span>
                            <span class="chat-file-name">@(file.Name.Length > 20 ? file.Name.Substring(0, 20) : file.Name)</span>
                        }
                        <button class="chat-file-remove" @onclick="() => RemoveFile(idx)">√ó</button>
                    </div>
                }
            </div>
        }
        <div class="chat-input-row">
            <label class="chat-attach-btn" for="chatFilePicker">
                <svg viewBox="0 0 24 24" width="20" height="20"><path d="M16.5 6v11.5c0 2.21-1.79 4-4 4s-4-1.79-4-4V5a2.5 2.5 0 0 1 5 0v10.5c0 .55-.45 1-1 1s-1-.45-1-1V6h-1.5v9.5a2.5 2.5 0 0 0 5 0V5c0-2.21-1.79-4-4-4S7 2.79 7 5v12.5c0 3.04 2.46 5.5 5.5 5.5s5.5-2.46 5.5-5.5V6H16.5z" fill="currentColor"/></svg>
            </label>
            <InputFile id="chatFilePicker" OnChange="OnFilesSelected" multiple
                       accept="image/*,.pdf,.txt,.csv,.json,.md,.xml,.log"
                       style="display:none" />
            <textarea class="chat-input" placeholder="Message" id="chatInput"
                      @onkeydown="OnKeyDown" @onkeydown:preventDefault="_preventEnter"
                      rows="1"></textarea>
            <button class="chat-send-btn @(_canSend ? "chat-send-active" : "")"
                    id="chatSendBtn" disabled="@(!_canSend)" @onclick="SendMessage">
                <svg viewBox="0 0 24 24" width="22" height="22"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z" fill="currentColor"/></svg>
            </button>
        </div>
    </div>
</div>

<style>
    .chat-page {
        display: flex;
        flex-direction: column;
        position: fixed;
        top: 68px;
        left: 0;
        right: 0;
        bottom: 0;
        background: #0d1117;
        z-index: 2;
        overflow: hidden;
        transition: top 0.3s ease;
    }
    .bars-hidden .chat-page {
        top: 0;
    }
    @@media (min-width: 769px) {
        .chat-page {
            top: 48px;
            left: 260px;
            bottom: 0;
        }
        .chat-input-bar {
            bottom: 0 !important;
            padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px)) !important;
        }
        .chat-messages {
            padding-bottom: 80px !important;
        }
        .chat-scroll-bottom {
            bottom: 70px !important;
        }
    }

    .chat-messages {
        flex: 1;
        overflow-y: auto;
        padding: 12px 16px 130px;
        display: flex;
        flex-direction: column;
        gap: 2px;
    }

    .chat-empty {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        flex: 1;
        gap: 8px;
        opacity: 0.7;
    }
    .chat-empty-icon { font-size: 3rem; }
    .chat-empty-title { font-size: 1.2rem; font-weight: 600; color: #e6edf3; }
    .chat-empty-sub { font-size: 0.8rem; color: #8b949e; text-align: center; }

    .chat-date-divider {
        text-align: center;
        margin: 16px 0 8px;
    }
    .chat-date-divider span {
        background: #1c2333;
        color: #8b949e;
        font-size: 0.7rem;
        padding: 4px 12px;
        border-radius: 10px;
        font-weight: 500;
    }

    .chat-row {
        display: flex;
        max-width: 95%;
        animation: msgIn 0.15s ease;
    }
    .chat-row-user { align-self: flex-end; }
    .chat-row-atlas { align-self: flex-start; }

    .chat-source-icon {
        font-size: 0.8rem;
        margin-bottom: 2px;
        opacity: 0.8;
    }

    .chat-bubble-user {
        background: #1a5276;
        border-radius: 18px 18px 4px 18px;
        padding: 8px 14px 6px;
    }
    .chat-bubble-atlas {
        background: #1c2333;
        border-radius: 18px 18px 18px 4px;
        padding: 8px 14px 6px;
        border: 1px solid rgba(255,255,255,0.05);
    }

    .chat-text {
        color: #e6edf3; font-size: 0.93rem; line-height: 1.45;
        white-space: pre-wrap; word-break: break-word;
    }
    .chat-text code {
        background: rgba(0,0,0,0.3); padding: 1px 5px; border-radius: 4px;
        font-size: 0.83rem; color: #f0883e;
    }
    .chat-text strong { color: #e6edf3; }
    .chat-time-user, .chat-time-atlas {
        font-size: 0.65rem; color: rgba(255,255,255,0.4); margin-top: 2px;
    }
    .chat-time-user { text-align: right; }
    .chat-time-atlas { text-align: left; }

    .chat-typing { display: flex; gap: 4px; padding: 4px 0; }
    .chat-typing .dot {
        width: 7px; height: 7px; border-radius: 50%;
        background: #8b949e; animation: typingBounce 1.4s ease infinite;
    }
    .chat-typing .dot:nth-child(2) { animation-delay: 0.2s; }
    .chat-typing .dot:nth-child(3) { animation-delay: 0.4s; }

    /* ‚îÄ‚îÄ Scroll to Bottom ‚îÄ‚îÄ */
    .chat-scroll-bottom {
        position: absolute;
        bottom: calc(68px + env(safe-area-inset-bottom, 0px));
        right: 16px;
        width: 38px; height: 38px;
        border-radius: 50%;
        border: 1px solid rgba(59,130,246,0.3);
        background: #30363d;
        color: #e6edf3;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer;
        z-index: 5;
        box-shadow: 0 3px 12px rgba(0,0,0,0.5);
        transition: all 0.2s;
    }
    .chat-scroll-bottom:hover {
        background: #3b82f6;
        color: #fff;
    }

    /* ‚îÄ‚îÄ File Preview Strip ‚îÄ‚îÄ */
    .chat-file-strip {
        display: flex;
        gap: 8px;
        padding: 0 4px;
        overflow-x: auto;
        pointer-events: auto;
    }
    .chat-file-strip:empty { display: none; }
    .chat-file-preview {
        position: relative;
        width: 64px; height: 64px;
        border-radius: 10px;
        overflow: hidden;
        flex-shrink: 0;
        border: 1px solid rgba(255,255,255,0.1);
        background: #1c2333;
    }
    .chat-file-preview img {
        width: 100%; height: 100%; object-fit: cover;
    }
    .chat-file-doc {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 2px;
    }
    .chat-file-icon { font-size: 1.4rem; }
    .chat-file-name {
        font-size: 0.55rem;
        color: #8b949e;
        text-align: center;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
        max-width: 56px;
    }
    .chat-file-remove {
        position: absolute;
        top: 2px; right: 2px;
        width: 18px; height: 18px;
        border-radius: 50%;
        border: none;
        background: rgba(0,0,0,0.7);
        color: #fff;
        font-size: 12px;
        line-height: 1;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* ‚îÄ‚îÄ Floating Input Bar ‚îÄ‚îÄ */
    .chat-input-bar {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        display: flex;
        flex-direction: column;
        gap: 6px;
        padding: 10px 12px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
        background: transparent;
        pointer-events: none;
    }
    .chat-input-bar > * {
        pointer-events: auto;
    }
    .chat-input-row {
        display: flex;
        align-items: flex-end;
        gap: 8px;
    }
    .chat-attach-btn {
        width: 40px; height: 40px; min-width: 40px;
        border-radius: 50%; border: none;
        background: rgba(22, 27, 34, 0.92);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.08);
        color: #8b949e;
        display: flex; align-items: center; justify-content: center;
        cursor: pointer; flex-shrink: 0;
        transition: all 0.2s;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .chat-attach-btn:hover {
        color: #e6edf3;
        background: rgba(30, 36, 44, 0.95);
        border-color: rgba(255,255,255,0.15);
    }
    .chat-input {
        flex: 1;
        background: rgba(22, 27, 34, 0.92);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 22px;
        outline: none;
        color: #e6edf3;
        font-size: 0.95rem;
        padding: 10px 16px;
        font-family: inherit;
        min-height: 24px;
        max-height: 200px;
        resize: none;
        overflow-y: auto;
        line-height: 1.4;
        transition: border-color 0.2s, box-shadow 0.2s;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 0 0 transparent;
    }
    .chat-input:focus {
        border-color: rgba(59,130,246,0.5);
        box-shadow: 0 4px 20px rgba(0,0,0,0.5), 0 0 0 1px rgba(59,130,246,0.2);
    }
    .chat-input::placeholder { color: #6e7681; }
    .chat-input:disabled { opacity: 0.5; }

    .chat-send-btn {
        width: 40px; height: 40px; min-width: 40px;
        border-radius: 50%; border: none;
        background: rgba(48, 54, 61, 0.92);
        backdrop-filter: blur(12px);
        -webkit-backdrop-filter: blur(12px);
        border: 1px solid rgba(255,255,255,0.08);
        color: #484f58;
        display: flex; align-items: center; justify-content: center;
        cursor: default; flex-shrink: 0; transition: all 0.2s;
        box-shadow: 0 4px 20px rgba(0,0,0,0.5);
    }
    .chat-send-btn.chat-send-active {
        background: #3b82f6; color: #fff; cursor: pointer;
    }
    .chat-send-btn.chat-send-active:active {
        transform: scale(0.92); background: #2563eb;
    }
    /* streaming state no longer needed - send always allowed */

    @@keyframes msgIn {
        from { opacity: 0; transform: translateY(6px); }
        to { opacity: 1; transform: translateY(0); }
    }
    @@keyframes typingBounce {
        0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
        30% { transform: translateY(-5px); opacity: 1; }
    }


</style>

@code {
    private List<ChatMessage> _messages = new();
    private bool _isStreaming = false;
    private string _streamBuffer = "";
    private bool _preventEnter = false;
    private CancellationTokenSource? _cts;
    private Timer? _pollTimer;
    private int _lastMessageCount = 0;
    private Queue<string> _messageQueue = new();
    private bool _processingQueue = false;
    private List<AttachedFile> _attachedFiles = new();
    private bool _canSend => _attachedFiles.Any() || _hasText;
    private bool _hasText;

    private class AttachedFile
    {
        public string Name { get; set; } = "";
        public string ContentType { get; set; } = "";
        public bool IsImage => ContentType.StartsWith("image/");
        public string? PreviewUrl { get; set; }
        public string? DataUrl { get; set; }
    }

    private class ChatMessage
    {
        public string Role { get; set; } = "";
        public string Content { get; set; } = "";
        public DateTime CreatedAt { get; set; }
    }

    protected override async Task OnInitializedAsync()
    {
        await LoadMessagesFromTranscript();
        // Poll for new messages every 3 seconds (catches Telegram messages)
        _pollTimer = new Timer(async _ => await PollForNewMessages(), null, 3000, 3000);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await JS.InvokeVoidAsync("chatPage.disableBodyScroll");
            await ScrollToBottom();
            await JS.InvokeVoidAsync("chatScroll.initScrollWatch", "chatMessages", "chatScrollBottom");
        }
        await JS.InvokeVoidAsync("chatInput.initResize", "chatInput");
    }

    private async Task LoadMessagesFromTranscript()
    {
        try
        {
            var client = HttpClientFactory.CreateClient();
            client.BaseAddress = new Uri("http://localhost:5263");
            // Use cookie from the current user's session - not needed for server-side calls
            var response = await client.GetAsync("/api/chat/history?limit=100");
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                using var doc = JsonDocument.Parse(json);
                var messagesArr = doc.RootElement.GetProperty("messages");

                _messages.Clear();
                foreach (var msg in messagesArr.EnumerateArray())
                {
                    var role = msg.GetProperty("role").GetString() ?? "";
                    var content = msg.GetProperty("content").GetString() ?? "";
                    var ts = msg.GetProperty("timestamp").GetString() ?? "";

                    DateTime createdAt = DateTime.UtcNow;
                    if (DateTime.TryParse(ts, null, System.Globalization.DateTimeStyles.RoundtripKind, out var parsed))
                        createdAt = parsed;

                    _messages.Add(new ChatMessage { Role = role, Content = content, CreatedAt = createdAt });
                }
                _lastMessageCount = _messages.Count;
            }
        }
        catch { }
    }

    private async Task PollForNewMessages()
    {
        if (_isStreaming) return; // Don't poll during streaming
        try
        {
            var client = HttpClientFactory.CreateClient();
            client.BaseAddress = new Uri("http://localhost:5263");
            var response = await client.GetAsync("/api/chat/history?limit=100");
            if (response.IsSuccessStatusCode)
            {
                var json = await response.Content.ReadAsStringAsync();
                using var doc = JsonDocument.Parse(json);
                var messagesArr = doc.RootElement.GetProperty("messages");
                var newCount = messagesArr.GetArrayLength();

                if (newCount > _lastMessageCount)
                {
                    // New messages arrived (from Telegram or another source)
                    _messages.Clear();
                    foreach (var msg in messagesArr.EnumerateArray())
                    {
                        var role = msg.GetProperty("role").GetString() ?? "";
                        var content = msg.GetProperty("content").GetString() ?? "";
                        var ts = msg.GetProperty("timestamp").GetString() ?? "";

                        DateTime createdAt = DateTime.UtcNow;
                        if (DateTime.TryParse(ts, null, System.Globalization.DateTimeStyles.RoundtripKind, out var parsed))
                            createdAt = parsed;

                        _messages.Add(new ChatMessage { Role = role, Content = content, CreatedAt = createdAt });
                    }
                    _lastMessageCount = _messages.Count;
                    await InvokeAsync(StateHasChanged);
                    await ScrollToBottom();
                }
            }
        }
        catch { }
    }

    private async Task OnFilesSelected(InputFileChangeEventArgs e)
    {
        foreach (var file in e.GetMultipleFiles(5))
        {
            var attached = new AttachedFile
            {
                Name = file.Name,
                ContentType = file.ContentType
            };

            // Read file to base64
            var maxSize = 10 * 1024 * 1024; // 10MB
            using var stream = file.OpenReadStream(maxSize);
            using var ms = new System.IO.MemoryStream();
            await stream.CopyToAsync(ms);
            var bytes = ms.ToArray();
            var base64 = Convert.ToBase64String(bytes);
            attached.DataUrl = $"data:{file.ContentType};base64,{base64}";

            if (attached.IsImage)
                attached.PreviewUrl = attached.DataUrl;

            _attachedFiles.Add(attached);
        }
        StateHasChanged();
    }

    private void RemoveFile(int index)
    {
        if (index >= 0 && index < _attachedFiles.Count)
            _attachedFiles.RemoveAt(index);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (e.Key == "Enter" && !e.ShiftKey)
        {
            _preventEnter = true;
            await SendMessage();
        }
        else
        {
            _preventEnter = false;
            // Update text state for send button
            var val = await JS.InvokeAsync<string>("chatInput.getValue", "chatInput");
            _hasText = !string.IsNullOrWhiteSpace(val);
        }
    }

    private async Task SendMessage()
    {
        var input = await JS.InvokeAsync<string>("chatInput.getValue", "chatInput");
        var hasFiles = _attachedFiles.Any();

        if (string.IsNullOrWhiteSpace(input) && !hasFiles) return;

        var userMsg = (input ?? "").Trim();
        await JS.InvokeVoidAsync("chatInput.clear", "chatInput");
        _hasText = false;

        // Grab files and clear
        var files = _attachedFiles.ToList();
        _attachedFiles.Clear();

        // Build display text
        var displayText = userMsg;
        if (files.Count > 0)
        {
            var fileNames = string.Join(", ", files.Select(f => f.Name));
            displayText = string.IsNullOrEmpty(userMsg)
                ? $"üìé {fileNames}"
                : $"{userMsg}\nüìé {fileNames}";
        }

        // Add to UI immediately
        _messages.Add(new ChatMessage { Role = "user", Content = displayText, CreatedAt = DateTime.UtcNow });
        StateHasChanged();
        await ScrollToBottom();

        // Build content for API
        _pendingFiles = files;
        _messageQueue.Enqueue(userMsg);
        await ProcessQueue();
    }

    private List<AttachedFile>? _pendingFiles;

    private async Task ProcessQueue()
    {
        if (_processingQueue) return; // Already processing
        _processingQueue = true;

        while (_messageQueue.Count > 0)
        {
            // Collect all queued messages into one batch
            var batch = new List<string>();
            while (_messageQueue.Count > 0)
                batch.Add(_messageQueue.Dequeue());

            var combined = string.Join("\n\n", batch);
            var files = _pendingFiles;
            _pendingFiles = null;

            _isStreaming = true;
            _streamBuffer = "";
            await InvokeAsync(StateHasChanged);

            _cts = new CancellationTokenSource();

            try
            {
                var gatewayUrl = Configuration["OpenClaw:GatewayUrl"] ?? "http://localhost:18789";
                var token = Configuration["OpenClaw:Token"] ?? "";
                var agentId = Configuration["OpenClaw:AgentId"] ?? "main";
                var sessionKey = Configuration["OpenClaw:SessionKey"] ?? "agent:main:main";

                var client = HttpClientFactory.CreateClient();
                client.Timeout = TimeSpan.FromMinutes(5);

                // Build message content ‚Äî multimodal if files attached
                object messageContent;
                if (files != null && files.Count > 0)
                {
                    var contentParts = new List<object>();
                    foreach (var file in files)
                    {
                        if (file.IsImage && file.DataUrl != null)
                        {
                            contentParts.Add(new { type = "image_url", image_url = new { url = file.DataUrl } });
                        }
                        else if (file.DataUrl != null)
                        {
                            // Non-image files: extract base64 content and send as text
                            var base64Part = file.DataUrl.Contains(",") ? file.DataUrl.Substring(file.DataUrl.IndexOf(",") + 1) : file.DataUrl;
                            try
                            {
                                var bytes = Convert.FromBase64String(base64Part);
                                var textContent = Encoding.UTF8.GetString(bytes);
                                contentParts.Add(new { type = "text", text = $"[File: {file.Name}]\n{textContent}" });
                            }
                            catch
                            {
                                contentParts.Add(new { type = "text", text = $"[File: {file.Name} (binary)]" });
                            }
                        }
                    }
                    if (!string.IsNullOrEmpty(combined))
                        contentParts.Add(new { type = "text", text = combined });
                    else if (contentParts.All(p => p.GetType().GetProperty("type")?.GetValue(p)?.ToString() == "image_url"))
                        contentParts.Add(new { type = "text", text = "What's in this image?" });
                    messageContent = contentParts;
                }
                else
                {
                    messageContent = combined;
                }

                var apiMessages = new[] { new { role = "user", content = messageContent } };
                var requestBody = new { model = "openclaw", stream = true, messages = apiMessages };

                var request = new HttpRequestMessage(HttpMethod.Post, $"{gatewayUrl}/v1/chat/completions");
                request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", token);
                request.Headers.Add("x-openclaw-agent-id", agentId);
                request.Headers.Add("x-openclaw-session-key", sessionKey);
                request.Content = new StringContent(JsonSerializer.Serialize(requestBody), Encoding.UTF8, "application/json");

                var response = await client.SendAsync(request, HttpCompletionOption.ResponseHeadersRead, _cts.Token);
                response.EnsureSuccessStatusCode();

                using var stream = await response.Content.ReadAsStreamAsync(_cts.Token);
                using var reader = new System.IO.StreamReader(stream);

                while (!reader.EndOfStream && !_cts.Token.IsCancellationRequested)
                {
                    var line = await reader.ReadLineAsync(_cts.Token);
                    if (string.IsNullOrEmpty(line)) continue;
                    if (!line.StartsWith("data: ")) continue;

                    var data = line.Substring(6);
                    if (data == "[DONE]") break;

                    try
                    {
                        using var doc = JsonDocument.Parse(data);
                        var choices = doc.RootElement.GetProperty("choices");
                        if (choices.GetArrayLength() > 0)
                        {
                            var delta = choices[0].GetProperty("delta");
                            if (delta.TryGetProperty("content", out var content))
                            {
                                var text = content.GetString();
                                if (!string.IsNullOrEmpty(text))
                                {
                                    _streamBuffer += text;
                                    await InvokeAsync(StateHasChanged);
                                    await ScrollToBottom();
                                }
                            }
                        }
                    }
                    catch (JsonException) { }
                }

                if (!string.IsNullOrEmpty(_streamBuffer))
                {
                    _messages.Add(new ChatMessage { Role = "assistant", Content = _streamBuffer, CreatedAt = DateTime.UtcNow });
                    _lastMessageCount = _messages.Count;

                    // Relay to Telegram
                    try
                    {
                        var relayClient = HttpClientFactory.CreateClient();
                        var relayPayload = JsonSerializer.Serialize(new { userMessage = combined, assistantMessage = _streamBuffer });
                        var relayResp = await relayClient.PostAsync("http://localhost:5263/api/chat/relay",
                            new StringContent(relayPayload, Encoding.UTF8, "application/json"));
                        var relayBody = await relayResp.Content.ReadAsStringAsync();
                        Console.WriteLine($"[Relay] Status={relayResp.StatusCode} Body={relayBody}");
                    }
                    catch (Exception relayEx)
                    {
                        Console.WriteLine($"[Relay] Error: {relayEx.Message}");
                    }
                }
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                _messages.Add(new ChatMessage { Role = "assistant", Content = $"‚ö†Ô∏è Connection error: {ex.Message}", CreatedAt = DateTime.UtcNow });
            }
            finally
            {
                _isStreaming = false;
                _streamBuffer = "";
                _cts?.Dispose();
                _cts = null;
            }
        }

        _processingQueue = false;
        await InvokeAsync(StateHasChanged);
        await ScrollToBottom();
    }

    private async Task ScrollToBottom()
    {
        try
        {
            await Task.Delay(30);
            await JS.InvokeVoidAsync("chatScroll.scrollToBottom", "chatMessages");
        }
        catch { }
    }

    private string GetUserSourceIcon(string content)
    {
        // Messages from Telegram have metadata prefix like "[Telegram..."
        // Messages from CP are plain text
        if (content != null && content.Contains("[Telegram"))
            return "‚úàÔ∏è"; // Telegram icon
        return "üì±"; // Control Panel icon
    }

    private string CleanSourcePrefix(string content)
    {
        if (string.IsNullOrEmpty(content)) return content;
        // Remove Telegram metadata prefix: [Telegram Name id:xxx ...] message
        // The actual message text follows the last ] on the first line
        if (content.StartsWith("[Telegram") || content.StartsWith("[Chat messages"))
        {
            var lastBracket = content.IndexOf("]\n");
            if (lastBracket > 0)
                return content.Substring(lastBracket + 2).TrimStart();
            lastBracket = content.IndexOf("] ");
            if (lastBracket > 0)
                return content.Substring(lastBracket + 2).TrimStart();
        }
        return content;
    }

    private string FormatMessage(string text)
    {
        if (string.IsNullOrEmpty(text)) return "";
        text = text.Replace("&", "&amp;").Replace("<", "&lt;").Replace(">", "&gt;");
        text = System.Text.RegularExpressions.Regex.Replace(text, @"`([^`]+)`", "<code>$1</code>");
        text = System.Text.RegularExpressions.Regex.Replace(text, @"\*\*([^*]+)\*\*", "<strong>$1</strong>");
        return text;
    }

    public async ValueTask DisposeAsync()
    {
        _pollTimer?.Dispose();
        _cts?.Cancel();
        _cts?.Dispose();
        try { await JS.InvokeVoidAsync("chatPage.enableBodyScroll"); } catch { }
    }
}
